Terminals:
variable string number + - % * / & ^ > < ! = ( ) ' " print for in range , from import as with open : True False None is not while if else def return class break pass continue raise
Variables:
S VAR VAL STRING NUMBER OPARITH OP PRINT FORHEAD VRANGE FUNCTION VFUNCTION FOR IMPORT WITH OPCOMP BOOLEAN NONE OPLOGIC OPIDENTITY WHILE COMP IF ELIF ELSE DEF VDEF VRET CLASS VCLASS BREAK PASS CONTINUE RAISE
Productions:
S -> S S | VAR = VAL | VAR + = STRING | VAR OPARITH = NUMBER | PRINT | FOR | IMPORT | WITH | WHILE | IF | DEF | CLASS | CONTINUE | BREAK | PASS;
VAR -> variable | VCLASS;
VAL -> VAR | STRING | NUMBER | ARRAY | FUNCTION | BOOLEAN | NONE | VCLASS ;
STRING -> STRING + STRING | ' string ' | " string " | ' string ' + ' string ' | " string " + " string " | " string " + ' string ' | ' string ' + " string " | ( STRING );
NUMBER -> NUMBER OPARITH NUMBER | number | number OPARITH number | number * * number | number / / number | number > > number | number < < number ( NUMBER );
OPARITH -> + | - | * | / | %;
OPCOMP -> < | > | !;
OP -> OPARITH | & | ^ | OPCOMP;
PRINT -> print ( VAL );
FORHEAD -> for VAR in range ( VRANGE ) | for VAR in VAL;
VRANGE -> VAL , VAL | VAL | VAL , VAL , VAL;
FUNCTION -> VAR ( VFUNCTION ) | FUNCTION ( FUNCTION );
VFUNCTION -> VFUNCTION , VFUNCTION | VAL;
FOR -> FORHEAD : S;
BOOLEAN -> True | False;
NONE -> None;
OPLOGIC -> and | or;
OPIDENTITY -> is | is not | in;
IMPORT -> from VAR import VAR | from VAR import * | import VAR | import VAR as VAR | from VAR import VAR as VAR;
WITH -> with open ( VAL ) as VAR : S;
WHILE -> while COMP : S;
COMP -> VAR | ( COMP ) | COMP OPLOGIC COMP | VAR OPCOMP VAL | VAR OPCOMP = VAL | VAR = = VAL | not VAR | VAR OPIDENTITY VAL;
RAISE -> raise ( VAL ) ;
BREAK -> break;
PASS -> pass;
CONTINUE -> continue;
IF -> if COMP : S | IF ELIF | IF ELSE | IF RAISE;
ELSE -> else : S;
ELIF -> else if COMP : S | ELIF ELIF | ELIF ELSE;
DEF -> def VAR ( VDEF ) : S return VRET | def VAR ( VDEF ) : S | def VAR ( ) : S return VRET | def VAR ( ) : S;
VDEF -> VDEF , VDEF | variable | VAR = VAL;
VRET -> VRET , VRET | variable | COMP | ( VRET );
CLASS -> class VAR : S | class ( VAR ) : S;
VCLASS -> VCLASS . VCLASS | variable