Terminals:
variable string number + - % * / & ^ > < ! = ( ) [ ] ' " print for in range , . from import as with open : True False None is not while if elif else def return class break pass continue raise input
Variables:
S SLOOP VAR VAL STRING NUMBER ARRAY VARRAY INDEX OPARITH OP PRINT VPRINT FORHEAD VRANGE FUNCTION VFUNCTION FOR IMPORT VIMPORT WITH VWITH OPCOMP BOOLEAN NONE OPLOGIC OPIDENTITY WHILE COMP IF VIF IFLOOP VIFL ELIF VELIF VELIF ELIFLOOP ELSE VELSE VELSEL ELSELOOP IFRET DEF DEFV VDEF VRET CLASS ICLASS VCLASS BREAK PASS CONTINUE RAISE EXCP COMPOPRT INPUT
Productions:
S -> S S | VAR = VAL | VAR + = STRING | VAR OPARITH = NUMBER | INDEX | PRINT | FOR | IMPORT | WITH | WHILE | IF | DEF | CLASS | FUNCTION | PASS | RAISE;
SLOOP -> SLOOP SLOOP | VAR = VAL | VAR + = STRING | VAR OPARITH = NUMBER | INDEX | PRINT | FOR | WITH | WHILE | IFLOOP | FUNCTION | PASS | RAISE | BREAK | CONTINUE;
VAR -> variable | VCLASS;
VAL -> VAR | STRING | NUMBER | ARRAY | FUNCTION | BOOLEAN | NONE | VCLASS | INPUT | INDEX;
STRING -> STRING + STRING | ' string ' | " string " | ' string ' + ' string ' | " string " + " string " | " string " + ' string ' | ' string ' + " string " | ( STRING );
NUMBER -> NUMBER OPARITH NUMBER | number | number OPARITH number | number * * number | number / / number | number > > number | number < < number | ( NUMBER ) | number . number | . number | + number | - number;
VARRAY -> VAL | VARRAY , VARRAY | ARRAY;
ARRAY -> [ ] | [ VARRAY ] | ( ) | ( VARRAY );
INDEX -> VAR [ NUMBER ] | VAR [ : ] | VAR [ : NUMBER ] | VAR [ NUMBER : ] | VAR [ NUMBER : NUMBER ];
OPARITH -> + | - | * | / | %;
OPCOMP -> < | > | !;
OP -> OPARITH | & | ^ | OPCOMP;
VPRINT -> VAL | VPRINT , VPRINT;
PRINT -> print ( VPRINT ) | print ( );
INPUT -> input ( VAL ) | ( INPUT ) | input ( );
FORHEAD -> for VAR in range ( VRANGE ) | for VAR in VAL | for VAR , VAR in VAL;
VRANGE -> VAL , VAL | VAL | VAL , VAL , VAL;
FUNCTION -> VAR ( VFUNCTION ) | FUNCTION ( FUNCTION ) | VAR ( );
VFUNCTION -> VFUNCTION , VFUNCTION | VAL;
FOR -> FORHEAD : SLOOP;
BOOLEAN -> True | False;
NONE -> None;
OPLOGIC -> and | or;
OPIDENTITY -> is | is not | in;
IMPORT -> from VAR import VIMPORT | from VAR import * | import VIMPORT | import VAR as VAR | from VAR import VAR as VAR;
VIMPORT -> VAR | VIMPORT , VIMPORT;
VWITH -> VAL | VAL , VAL | VAL , VAL , VAL | VAL , VAL , VAL , VAL | VAL , VAL , VAL , VAL , VAL | VAL , VAL , VAL , VAL , VAL , VAL | VAL , VAL , VAL , VAL , VAL , VAL , VAL | VAL , VAL , VAL , VAL , VAL , VAL , VAL , VAL;
WITH -> with open ( VWITH ) : S | with open ( VWITH ) as VAR : S;
WHILE -> while COMP : SLOOP;
COMP -> BOOLEAN | VAR | ( COMP ) | COMP OPLOGIC COMP | COMPOPRT OPCOMP COMPOPRT | COMPOPRT OPCOMP = COMPOPRT | COMPOPRT = = COMPOPRT | not VAR | not COMP | COMPOPRT OPIDENTITY COMPOPRT;
COMPOPRT -> COMPOPRT OPARITH COMPOPRT | VAL | VAL OPARITH VAL | VAL * * VAL | VAL / / VAL | VAL > > VAL | VAL < < VAL | ( COMPOPRT );
RAISE -> raise VAR ( STRING ) | raise ( STRING ) | raise ( );
BREAK -> break;
PASS -> pass;
CONTINUE -> continue;
VIF -> if COMP : S | if COMP : IFRET;
VELIF -> elif COMP : S | elif COMP : IFRET;
VELSE -> else : S | else : IFRET;
IF -> VIF | VIF ELIF | VIF ELSE | VIF RAISE | VIF RAISE ELIF | VIF RAISE ELSE | VIF PASS | VIF PASS ELIF | VIF PASS ELSE;
ELIF -> VELIF | VELIF ELIF | VELIF ELSE | VELIF RAISE | VELIF RAISE ELIF | VELIF RAISE ELSE | VELIF PASS | VELIF PASS ELIF | VELIF PASS ELSE;
ELSE -> VELSE | VELSE RAISE | VELSE PASS;
VIFL -> if COMP : SLOOP | if COMP : IFRET;
VELIFL -> elif COMP : SLOOP | elif COMP : IFRET;
VELSEL -> else : SLOOP | else : IFRET;
IFLOOP -> VIFL | VIFL ELIFLOOP | VIFL ELSELOOP | VIFL RAISE | VIFL RAISE ELIFLOOP | VIFL RAISE ELSELOOP | VIFL PASS | VIFL PASS ELIFLOOP | VIFL PASS ELSELOOP | VIFL CONTINUE | VIFL CONTINUE ELIFLOOP | VIFL CONTINUE ELSELOOP | VIFL BREAK | VIFL BREAK ELIFLOOP | VIFL BREAK ELSELOOP;
ELIFLOOP -> VELIFL | VELIFL ELIFLOOP | VELIFL ELSELOOP | VELIFL RAISE | VELIFL RAISE ELIFLOOP | VELIFL RAISE ELSELOOP | VELIFL PASS | VELIFL PASS ELIFLOOP | VELIFL PASS ELSELOOP | VELIFL CONTINUE | VELIFL CONTINUE ELIFLOOP | VELIFL CONTINUE ELSELOOP | VELIFL BREAK | VELIFL BREAK ELIFLOOP | VELIFL BREAK ELSELOOP;
ELSELOOP -> VELSEL | VELSEL RAISE | VELSEL PASS | VELSEL CONTINUE | VELSEL BREAK | else : BREAK;
IFRET -> S return VRET | return VRET | S return | return;
DEF -> DEFV : S return VRET | DEFV : S return | DEFV : S;
DEFV -> def VAR ( VDEF ) | def VAR ( );
VDEF -> VDEF , VDEF | variable | VAR = VAL;
VRET -> VRET , VRET | variable | COMP | ( VRET ) | NUMBER | BOOLEAN | STRING | NONE;
ICLASS -> VAR | ICLASS , ICLASS;
CLASS -> class VAR : S | class VAR ( ICLASS ) : S;
VCLASS -> VCLASS . VCLASS | VCLASS . FUNCTION | variable | FUNCTION